<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Metaprogramming for dummies</title>

        <meta name="author" content="Louis Dionne">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown=""
                         data-separator="^====+$"
                         data-separator-vertical="^----+$"
                         data-notes="^Note:">
                <script type="text/template">

## Metaprogramming for dummies
### Louis Dionne, C++Now 2016

<!--
TRY TO:
    + show some real-world repetitive C++ code
    + Show stuff that people write in Python
    + Show what we would like to "express" in C++

DO NOT FORGET:
    + Focus on things that will make them more productive on a daily basis
    + This is for beginners
 -->
==============================================================================

### Why do we need this talk?

<!--
If needed, define new MathJax commands just below this to avoid seeing
them load on the first slide.
-->

----

### Because metaprogramming is hard?

----

### Or because it's taught the wrong way?

----

### I think it's the latter

====================

### I'll do my best to break the mold
#### But please forget what you already know <!-- .element class="fragment" -->

==============================================================================

## Part 1
### Kinds of computation in C++

====================

### Runtime computations (classic)

----

### Runtime sequences

```c++
std::vector<int> ints{1, 2, 3, 4};
```

----

### Runtime functions

```c++
std::string f(int i) {
  return std::to_string(i * i);
}

std::string nine = f(3);
```

----

### Runtime algorithms

```c++
std::vector<std::string> strings;
std::transform(ints.begin(), ints.end(),
               std::back_inserter(strings), f);
```

====================

### `constexpr` computations

----

### `constexpr` sequences

```c++
constexpr std::array<int, 4> ints{1, 2, 3, 4};
```

----

### `constexpr` functions

```c++
constexpr int factorial(int n) {
  return n == 0 ? 1 : n * factorial(n - 1);
}

constexpr int six = factorial(3);
```

----

### `constexpr` algorithms

```c++
template <typename T, std::size_t N, typename F>
  constexpr std::array<std::result_of_t<F(T)>, N>
transform(std::array<T, N> array, F f) {
  // ...
}

constexpr std::array<int, 4> ints{1, 2, 3, 4};
constexpr std::array<int, 4> facts = transform(ints, factorial);
```

====================

### No surprise so far

====================

### In Python, we can write

```python
xs = [1, "two", 3.3]
print type(xs[0])
print type(xs[1])
print type(xs[2])
```

```
<type 'int'>
<type 'str'>
<type 'float'>
```


Note:
The list conceptually contains objects of different types.

----

### Not possible in C++

```c++
struct Cat  { };
struct Dog  { };
struct Fish { };

std::vector<???> xs{Cat{}, Dog{}, Fish{}};
std::cout << typeid(xs[0]).name() << std::endl;
std::cout << typeid(xs[1]).name() << std::endl;
std::cout << typeid(xs[2]).name() << std::endl;
```

----

### We do have polymorphism

----

### Well, runtime polymorphism

```c++
struct Animal { virtual ~Animal() { } };
struct Cat  : Animal { };
struct Dog  : Animal { };
struct Fish : Animal { };

std::vector<Animal*> xs{new Cat, new Dog, new Fish};
std::cout << typeid(*xs[0]).name() << std::endl;
std::cout << typeid(*xs[1]).name() << std::endl;
std::cout << typeid(*xs[2]).name() << std::endl;
//           ^^^^^^^^^^^^^^ non-trivial runtime work done here
```

```
Cat
Dog
Fish
```

Note:
The vector really contains pointers, which have a single type.
The _actual_ types of the elements is not known until runtime.

====================

### If the number of elements is known in advance...

----

### Then we also have static polymorphism

```c++
struct Cat  { }; //
struct Dog  { }; // No need for inheritance and virtual functions
struct Fish { }; //

std::tuple<Cat, Dog, Fish> xs{Cat{}, Dog{}, Fish{}};
std::cout << typeid(std::get<0>(xs)).name() << std::endl;
std::cout << typeid(std::get<1>(xs)).name() << std::endl;
std::cout << typeid(std::get<2>(xs)).name() << std::endl;
//           ^^^^^^^^^^^^^^^^^^^^^^^ known at compile-time
```

```
Cat
Dog
Fish
```

----

### Which brings us to...

====================

### Heterogeneous computations

----

### Heterogeneous sequences

```c++
std::tuple<int, std::string, float> seq{1, "abc", 3.4f};
```

----

### Heterogeneous functions

```c++
struct to_string {
  template <typename T>
  std::string operator()(T t) const {
    std::stringstream ss;
    ss << t;
    return ss.str();
  }
};

std::string three = to_string{}(3);
std::string pi = to_string{}(3.14159);
```

----

### Heterogeneous algorithms

```c++
std::tuple<int, std::string, float> seq{1, "abc", 3.4f};
std::tuple<std::string, std::string, std::string> strings =
              std::transform(seq, to_string{});
```

====================

### This is where (static) metaprogramming happens

==============================================================================

## Part 2
### Heterogeneous algorithms

====================

### Setup

<pre><code class="sample" sample="code/algorithms.cpp#setup"></code></pre>

====================

### Iterating

<pre><code class="sample" sample="code/algorithms.cpp#for_each"></code></pre>

====================

### Transforming

<pre><code class="sample" sample="code/algorithms.cpp#transform"></code></pre>

====================

### Removing some elements

<pre><code class="sample" sample="code/algorithms.cpp#remove_if"></code></pre>

====================

### Partitioning

<pre><code class="sample" sample="code/algorithms.cpp#partition"></code></pre>

====================

### Searching

<pre><code class="sample" sample="code/algorithms.cpp#find_if"></code></pre>

====================

### Counting

<pre><code class="sample" sample="code/algorithms.cpp#count_if"></code></pre>

====================

### Reversing

<pre><code class="sample" sample="code/algorithms.cpp#reverse"></code></pre>

==============================================================================

## Part 3
### Heterogeneous data structures

====================

<!-- TODO: Just like at runtime, it makes sense to have different data structures in the heterogeneous world. -->













==============================================================================



### A first example: multiple return values

<!-- TODO:
    Find an interesting example of multiple return values. This will introduce
    tuple through one of its most common use cases. Then, show something repetitive
    we might want to perform on the return values in the tuple. Use Hana to
    remove the repetition.

    Covers:
        - hana::tuple
        - hana::for_each
-->

====================

### Network protocols

<!-- TODO:
    Show example based on Thomas Rodger's presentation at CppCon 2014.

    Covers
        - Adapting user defined types
-->

====================

### Event system

<!-- TODO:
    Show a simple example of an event system. The events are compile-time
    strings and they are fixed at compile-time. We can dynamically add
    listeners to an event. This is basically a map of compile-time strings
    to std::vector<std::function>.

    Covers:
        - hana::map
        - compile-time strings
        - could expand to cover hana::find
-->

====================

### Manipulating types


<!-- TODO:
    We have a list of classes known at compile-time. We want to perform some
    function for each class at program initialization.

    Introduces:
        - hana::type
-->

<!-- NOTE:
    We can introduce type computations by introducing RTTI and type_index.
    Then, we introduce STI (static type information) as hana::type, and show
    how it can be used.
 -->

====================

### ...

<!-- TODO:
    Find an interesting example with type traits, to show how types can be
    manipulated.

    Covers:
        - hana::type
        - type traits
-->

====================

### Dimensional analysis

<!-- TODO:
    Implement a basic system for dimensional analysis (see MPL book p.39).

    Covers:
        - type-level computations
        - hana::fold, hana::zip
-->

====================

### Bonus: automatic parallelization

<!-- TODO:
    Show a simple example of how we can build a network of computations whose
    dependencies are known at compile-time, and then order them to satisfy the
    dependencies and finally run them in parallel. This might be too advanced.
-->

====================

# Thank you

<span class="fragment fade-in">
http://ldionne.com <br>
http://github.com/ldionne
</span>


                </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <!-- Required for the sampler.js plugin -->
        <script src="lib/js/jquery.min.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: true,
                history: true,
                transition: 'slide',

                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true },
                    { src: 'plugin/sampler/sampler.js' }
                ]
            });
        </script>
    </body>
</html>
