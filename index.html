<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Metaprogramming for dummies</title>

        <meta name="author" content="Louis Dionne">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <link rel="stylesheet" href="css/custom.css">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown=""
                         data-separator="^====+$"
                         data-separator-vertical="^----+$"
                         data-notes="^Note:">
                <script type="text/template">

## Metaprogramming for dummies
### Louis Dionne, C++Now 2016

<!--
TRY TO:
    + show some real-world repetitive C++ code
    + Show stuff that people write in Python
    + Show what we would like to "express" in C++

DO NOT FORGET:
    + Focus on things that will make them more productive on a daily basis
    + This is for beginners
 -->
==============================================================================

### Why do we need this talk?

<!--
If needed, define new MathJax commands just below this to avoid seeing
them load on the first slide.
-->

----

### Because metaprogramming is hard?

----

### Or because it's taught the wrong way?

----

### I think it's the latter

====================

### I'll do my best to break the mold
#### But please forget what you already know <!-- .element class="fragment" -->

==============================================================================

## Part 1
### Why you need metaprogramming

====================

### Let's register classes

<pre><code class="sample" sample="code/classreg_naive.cpp#main"></code></pre>

----

### How to allow registering many at once?

----

### Classic solution

<pre><code class="sample" sample="code/classreg_recursive.cpp#main"></code></pre>

----

### Drawbacks

- Not straightforward
- Not reusable

----

### In Python, we can write

```python
class A: pass
class B: pass
class C: pass

def register(classes):
    for c in classes:
        print "Registering " + c.__name__

register([A, B, C])
```

Note:
This works because types are first class citizens

----

### What we would like to write in C++

```c++
void register_(std::vector<...> const& classes) {
    for (auto c : classes)
        std::cout << "Registering " << c.name()
                  << ", which is of size " << sizeof(c) << std::endl;
}

int main() {
    std::vector<...> classes{...};
    register_(classes);
}
```

----

### Why this doesn't work?

```c++
void register_(std::vector<std::type_info> const& classes) {
    for (auto c : classes)
        std::cout << "Registering " << c.name()
                  << ", which is of size " << sizeof(c) << std::endl;
}

int main() {
    std::vector<std::type_info> classes{typeid(A), typeid(B),
                                        typeid(C)};
    register_(classes);
}
```

Note:
We need the size of each __type__, not that of `std::type_info` itself.
This is a reasonable requirement.

Also, if `type_info` provided a `size()` method, it would still not be
available at compile-time.

====================

### Let's generate JSON

```c++
struct Person {
    std::string name;
    int age;
};

int main() {
    Person joe{"Joe", 30};
    std::cout << to_json(joe);
}
```

----

### In Python, we could write

```python
def to_json(obj):
    members = []
    for member in obj.__dict__:
        members.append('"' + member + '" : ' +
                            str(getattr(obj, member)))
    return '{' + ', '.join(members) + '}'

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

print to_json(Person("John", 30))
```

Note:
Of course, this is a simplified version and it only handles objects.

----

### In C++, not so

```c++
template <typename T>
std::string to_json(T const& obj) {
    std::vector<std::string> members;
    for (std::string const& member : obj.__members__()) // ???
        members.push_back('"' + member + "\" : " +
                                to_json(obj.__get__(member))); // ???

    return boost::algorithm::join(members, ", ");
}
```

==============================================================================

## Part 2
### The three worlds of C++

Note:
By now, I would expect the audience to understand why metaprogramming might
be useful in the context of C++.

====================

## The runtime realm

----

### Runtime sequences and data types

```c++
std::vector<int> ints{1, 2, 3, 4};

std::string foobar = "foobar";

std::unordered_map<std::string, int> map{
    {"one", 1}, {"two", 2}, {"three", 3}
};
```

----

### Runtime functions

```c++
std::string f(int i) {
  return std::to_string(i * i);
}

std::string nine = f(3);
```

----

### Runtime algorithms

```c++
std::vector<std::string> strings;
std::transform(ints.begin(), ints.end(),
               std::back_inserter(strings), f);
```

====================

## The constexpr kingdom

----

### `constexpr` sequences and data types

```c++
constexpr std::array<int, 4> ints{1, 2, 3, 4};

constexpr std::string_view foobar = "foobar";
```

----

### `constexpr` functions

```c++
constexpr int factorial(int n) {
  return n == 0 ? 1 : n * factorial(n - 1);
}

constexpr int six = factorial(3);
```

----

### `constexpr` algorithms

```c++
template <typename T, std::size_t N, typename F>
  constexpr std::array<std::result_of_t<F(T)>, N>
transform(std::array<T, N> array, F f) {
  // ...
}

constexpr std::array<int, 4> ints{1, 2, 3, 4};
constexpr std::array<int, 4> facts = transform(ints, factorial);
```

====================

### No surprise so far

----

### What's the third world?

====================

### In Python, we can write

```python
xs = [1, "two", 3.3]
print type(xs[0])
print type(xs[1])
print type(xs[2])
```

```
<type 'int'>
<type 'str'>
<type 'float'>
```


Note:
The list conceptually contains objects of different types.

----

### Not possible in C++

```c++
struct Cat  { };
struct Dog  { };
struct Fish { };

std::vector<???> xs{Cat{}, Dog{}, Fish{}};
std::cout << typeid(xs[0]).name() << std::endl;
std::cout << typeid(xs[1]).name() << std::endl;
std::cout << typeid(xs[2]).name() << std::endl;
```

----

### Well, we do have runtime polymorphism

```c++
struct Animal { virtual ~Animal() { } };
struct Cat  : Animal { };
struct Dog  : Animal { };
struct Fish : Animal { };

std::vector<Animal*> xs{new Cat, new Dog, new Fish};
std::cout << typeid(*xs[0]).name() << std::endl;
std::cout << typeid(*xs[1]).name() << std::endl;
std::cout << typeid(*xs[2]).name() << std::endl;
//           ^^^^^^^^^^^^^^ non-trivial runtime work done here
```

```
Cat
Dog
Fish
```

Note:
The vector really contains pointers, which have a single type.
The _actual_ types of the elements is not known until runtime.

----

### But we're really manipulating pointers to a single type

----

### Which brings us to...

====================

## The heterogeneous territory

----

### Heterogeneous sequences and data types

```c++
hana::tuple<int, std::string, float> seq{1, "abc", 3.4f};

auto map = hana::make_map(
    hana::make_pair("one"_s, 1),
    hana::make_pair("two"_s, 2),
    hana::make_pair("three"_s, 3)
);
```

----

### Heterogeneous functions

```c++
struct to_string {
  template <typename T>
  std::string operator()(T t) const {
    std::stringstream ss;
    ss << t;
    return ss.str();
  }
};

std::string three = to_string{}(3);
std::string pi = to_string{}(3.14159);
```

----

### Heterogeneous algorithms

```c++
hana::tuple<int, std::string, float> seq{1, "abc", 3.4f};
hana::tuple<std::string, std::string, std::string> strings =
              hana::transform(seq, to_string{});
```

====================

### This place was once engulfed into darkness

----

### But now, it's a magic place where (static) metaprogramming happens

----

### You might even get lucky

<img src="img/unicorn.png" width="50%" height="50%"></img>

==============================================================================

## Part 3
### Heterogeneous data structures and algorithms

Note:
By now, I would expect the audience to understand what is the particularity
of the data structures and algorithms we will be considering (i.e. heterogeneous).

Just like at runtime, it makes sense to have different data structures in
the heterogeneous world.

====================

### Tuple

<pre><code class="sample" sample="code/tuple.cpp#setup"></code></pre>

Note:
Equivalent to std::vector for the heterogeneous world.
The simplest and most useful container.

----

### Indexing

<pre><code class="sample" sample="code/tuple.cpp#indexing"></code></pre>

----

### Basically equivalent to

<pre><code class="sample" sample="code/tuple.cpp#anon_struct"></code></pre>

----

### Inserting

<pre><code class="sample" sample="code/tuple.cpp#insert"></code></pre>

----

### Removing

<pre><code class="sample" sample="code/tuple.cpp#remove_at"></code></pre>

----

### Iterating

<pre><code class="sample" sample="code/tuple.cpp#for_each"></code></pre>

----

### Transforming

<pre><code class="sample" sample="code/tuple.cpp#transform"></code></pre>

----

### Filtering out

<pre><code class="sample" sample="code/tuple.cpp#remove_if"></code></pre>

----

### Partitioning

<pre><code class="sample" sample="code/tuple.cpp#partition"></code></pre>

----

### Searching

<pre><code class="sample" sample="code/tuple.cpp#find_if"></code></pre>

----

### Counting

<pre><code class="sample" sample="code/tuple.cpp#count_if"></code></pre>

----

### Reversing

<pre><code class="sample" sample="code/tuple.cpp#reverse"></code></pre>

====================

### Map

<pre><code class="sample" sample="code/map.cpp#setup"></code></pre>

----

### Accessing keys

<pre><code class="sample" sample="code/map.cpp#accessing"></code></pre>

----

### Querying

<pre><code class="sample" sample="code/map.cpp#contains"></code></pre>

----

### Inserting

<pre><code class="sample" sample="code/map.cpp#insert"></code></pre>

----

### Removing

<pre><code class="sample" sample="code/map.cpp#erase_key"></code></pre>

==============================================================================

## Part 4
### Using our tools

TODO


==============================================================================



### A first example: multiple return values

<!-- TODO:
    Find an interesting example of multiple return values. This will introduce
    tuple through one of its most common use cases. Then, show something repetitive
    we might want to perform on the return values in the tuple. Use Hana to
    remove the repetition.

    Covers:
        - hana::tuple
        - hana::for_each
-->

====================

### Network protocols

<!-- TODO:
    Show example based on Thomas Rodger's presentation at CppCon 2014.

    Covers
        - Adapting user defined types
-->

====================

### Event system

<!-- TODO:
    Show a simple example of an event system. The events are compile-time
    strings and they are fixed at compile-time. We can dynamically add
    listeners to an event. This is basically a map of compile-time strings
    to std::vector<std::function>.

    Covers:
        - hana::map
        - compile-time strings
        - could expand to cover hana::find
-->

====================

### Manipulating types


<!-- TODO:
    We have a list of classes known at compile-time. We want to perform some
    function for each class at program initialization.

    Introduces:
        - hana::type
-->

<!-- NOTE:
    We can introduce type computations by introducing RTTI and type_index.
    Then, we introduce STI (static type information) as hana::type, and show
    how it can be used.
 -->

====================

### ...

<!-- TODO:
    Find an interesting example with type traits, to show how types can be
    manipulated.

    Covers:
        - hana::type
        - type traits
-->

====================

### Dimensional analysis

<!-- TODO:
    Implement a basic system for dimensional analysis (see MPL book p.39).

    Covers:
        - type-level computations
        - hana::fold, hana::zip
-->

====================

### Bonus: automatic parallelization

<!-- TODO:
    Show a simple example of how we can build a network of computations whose
    dependencies are known at compile-time, and then order them to satisfy the
    dependencies and finally run them in parallel. This might be too advanced.
-->

====================

# Thank you

<span class="fragment fade-in">
http://ldionne.com <br>
http://github.com/ldionne
</span>


                </script>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <!-- Required for the sampler.js plugin -->
        <script src="lib/js/jquery.min.js"></script>

        <script>
            Reveal.initialize({
                slideNumber: true,
                history: true,
                transition: 'slide',

                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true },
                    { src: 'plugin/sampler/sampler.js' }
                ]
            });
        </script>
    </body>
</html>
